<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shopper+ Team Blog</title>
    <description>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</description>
    <link>http://shopperplus.github.io/blog/</link>
    <atom:link href="http://shopperplus.github.io/blog/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 14 Nov 2014 16:22:50 +0800</pubDate>
    <lastBuildDate>Fri, 14 Nov 2014 16:22:50 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>Upload resources to AWS using asset sync </title>
        <description>&lt;h3&gt;目的&lt;/h3&gt;

&lt;p&gt;网站的规模逐渐变大，响应的速度也逐渐变慢，其中图片的时间是主要的问题。选择把js css 图片这些文件放到aws有一下几个原因：
1、减少本服务器的负载
2、我们网站拥有多个域名，即使是同一个产品，在不同子站显示，图片都要重新加载一遍。一旦统一使用aws，不同子站都是请求同一图片地址，浏览器可以做缓存。
3、避免重复繁琐的图片上传管理操作，直接通过代码管理&lt;/p&gt;

&lt;h3&gt;使用asset sync&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rumblelabs/asset_sync&quot;&gt;asset sync&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用的时候进行简单的配置即可，其中遇到一个问题，插件在dev &amp;amp; staging都可以正确的运行，在production的时候提示&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;[2014-11-12T04:17:44.818010 #788] ERROR -- : uninitialized constant AssetSync (NameError)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大致的原因：
由于js css 与图片是能够正确上传到s3的，所以说明插件在 precomplice之后有正确的运行，但是启动unicorn的时候报错，可能是启动的时候已经不需要到这个变量，所以没有初始化，但是代码中却没有对这个进行判断。&lt;/p&gt;

&lt;p&gt;修改如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;if defined?(AssetSync)
...
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;使用后发现的问题最终放弃&lt;/h3&gt;

&lt;p&gt;1、无法使用gzip。使用的s3服务器中没有cloudfront，导致无法识别HTTP HEAD中Content-Encoding:gzip的请求，导致使用只能请求到非gz后的 js 与 css 文件，网站整体的pagespeed反而下降了。&lt;/p&gt;

&lt;p&gt;2、工作流程导致无法运用。前端工程师不使用rails server进行代码的编写，例如图片的url需要写成asset&lt;em&gt;host:XXXX,导致使用asset&lt;/em&gt;host指向s3后，他们无法在本地进行开发工作。&lt;/p&gt;

&lt;p&gt;3、代码中历史遗留的问题。旧代码中保留了不少直接使用public的图片，而public的图片不能被上传到s3中，不能直接使用asset sync，需要进行大量的修改。&lt;/p&gt;
</description>
        <pubDate>Fri, 14 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/2014/11/14/upload-resources-to-aws-using-asset-sync.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/2014/11/14/upload-resources-to-aws-using-asset-sync.html</guid>
        
        
      </item>
    
      <item>
        <title>You do not know NewRelic</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/0443c9ac79a6492aad4810c472308b97.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;Enabling garbage collection instrumentation&lt;/h2&gt;

&lt;p&gt;默认情况，Newrelic的Transactions response time overview 页面是没有统计GC信息的。如果想要开启只需要在&lt;code&gt;config/initializers/new_relic_unicorn.rb&lt;/code&gt;添加如下代码(如果不是unicorn只需要最后一句)：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;# -*- encoding : utf-8 -*-
# Ensure the agent is started using Unicorn.
# This is needed when using Unicorn and preload_app is not set to true.
# See https://docs.newrelic.com/docs/ruby/no-data-with-unicorn
if defined? Unicorn
  ::NewRelic::Agent.manual_start()
  ::NewRelic::Agent.after_fork(:force_reconnect =&amp;gt; true)
end

GC::Profiler.enable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Recording deployments&lt;/h2&gt;

&lt;p&gt;New Relic 支持自定义Event，结合 Capistrano 可以把每次发布的时间点划到图表上，题图上到三条粉丝细线就是deployment时刻。
同时，还可以把changelog信息一并记录下来，便于追踪各个版本差异产生的原因，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/7ffc389aed2e1443bbcd5ddf2f74d32c.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;实现这样酷的功能只需要两行代码，在&lt;code&gt;deploy.rb&lt;/code&gt;里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;require &amp;#39;new_relic/recipes&amp;#39;

after &amp;quot;deploy:updated&amp;quot;, &amp;quot;newrelic:notice_deployment&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你不需要发布就可以测试这个功能是否设置正确：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;cap newrelic:notice_deployment -Snewrelic_desc=&amp;quot;Deploying beta Krakatau release&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Availability monitoring&lt;/h2&gt;

&lt;p&gt;默认情况下，Newrelic会在网站响应速度低到一定阀值邮件通知，也可以手动设置 &lt;code&gt;Availability monitoring&lt;/code&gt;，
需要提供某个页面到URL，如果这个URL一分钟内ping不通就会收到网站 downtime 邮件。&lt;/p&gt;

&lt;h2&gt;Instrumentation Redis&lt;/h2&gt;

&lt;p&gt;只需Gemfile里添加 &lt;code&gt;newrelic-redis&lt;/code&gt; 这个gem，前提是你用了 &lt;code&gt;redis-rb&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一定有同学会问，Redis都那么快了还需要监控？&lt;/p&gt;

&lt;p&gt;原因很简单：&lt;/p&gt;

&lt;p&gt;默认情况下Newrelic会把请求时间算在Ruby／View里，这样你发现一个很慢的页面渲染，你无法定位到具体是什么东西那么慢。
加上 &lt;code&gt;newrelic-redis&lt;/code&gt;之后这部分时间被清晰到记录在Database catalog，并且可以和view其他部分区分开, 细致到每个redis指令执行到时间：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/9532c2a296f8e30b1107f6d93eb1e2fe.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;Instrumentation Rack Middleware&lt;/h2&gt;

&lt;p&gt;只需要升级 &lt;code&gt;newrelic_rpm&lt;/code&gt; 到 3.9.0 或以上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/22bdbf838583e4d6578ccf01c458aad0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/f9e38c001dd51e040f68223e41ff399c.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2&gt;JS Error Notification&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/a171111fbe6cf8d6275c5f2d83ca8db9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;就是ExceptionNotify的JS云端版本。当然，这个功能已经有很多人在做了，并不是newrelic首创。但集成到newrelic里却是非常自然，监控异常的同时还可以监控JS错误，何乐而不为呢..&lt;/p&gt;

&lt;h2&gt;NewRelic Insights&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://ruby-china-files.b0.upaiyun.com/photo/2014/74dab3fcea4ddc6d836c4b04c238ab86.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;这是一个beta项目，NewRelic把自己收集的数据再开放给你。通过自定义的NRQL，让你可以按照自己关心的方式自定义Dashboard。有了API，你可以再把这些数据倒回自己倒应用，和自己已有的数据做进一步分析。&lt;/p&gt;

&lt;h2&gt;Custom Variable&lt;/h2&gt;

&lt;p&gt;Google Analytics 很早就有了，有了这个东西可玩性就提高了一个层次。能做什么就由开发者自己来想像了。&lt;/p&gt;

&lt;h2&gt;NewRelic 和 Twitter的吞吐量相当，数据库使用的是 MySQL（Percona）&lt;/h2&gt;

&lt;p&gt;Renferer: http://www.slideshare.net/newrelic/how-to-build-a-saas-app-with-twitterlike-throughput-on-just-9-servers&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;相关文档
* https://docs.newrelic.com/docs/ruby/garbage-collection
* https://docs.newrelic.com/docs/ruby/recording-deployments-with-the-ruby-agent
* http://blog.newrelic.com/2014/07/02/ruby-agent-now-automatically-instruments-rack-middlewares&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/2014/11/08/you-do-not-know-newrelic.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/2014/11/08/you-do-not-know-newrelic.html</guid>
        
        
      </item>
    
      <item>
        <title>Chorisia tree</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://gp1.wac.edgecastcdn.net/806614/photos/photos.500px.net/34845288/a093afe9d576137dfdf9537724f27f043685a1a0/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/tree/2014/11/08/the-title-of-the-new-post.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/tree/2014/11/08/the-title-of-the-new-post.html</guid>
        
        
        <category>tree</category>
        
      </item>
    
      <item>
        <title>Fastest Way To Load Data In MySQL</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://www.runrares.ro/_imgArticol/viteza.jpg&quot; alt=&quot;fast&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.coffeepowered.net/2009/01/23/mass-inserting-data-in-rails-without-killing-your-performance/&quot;&gt;Mass inserting data in Rails without killing your performance&lt;/a&gt; 这篇文章里提到Rails快速批量插入数据的几种方式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Use transactions&lt;/li&gt;
&lt;li&gt;Get down and dirty with the raw SQL&lt;/li&gt;
&lt;li&gt;A single mass insert&lt;/li&gt;
&lt;li&gt;Use INSERT statements with multiple VALUES lists with &lt;a href=&quot;https://github.com/zdennis/ar-extensions&quot;&gt;ar-extensions&lt;/a&gt; OR &lt;a href=&quot;https://github.com/zdennis/activerecord-import&quot;&gt;activerecord-import&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第四种方式是AR方式的70倍左右，已经很快了，还有更快的吗？&lt;/p&gt;

&lt;p&gt;From MySQL Doc:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When loading a table from a text file, use LOAD DATA INFILE. This is usually 20 times faster than using INSERT statements&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SQL语句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(15955.1ms)  LOAD DATA LOCAL INFILE &amp;#39;/Users/hooopo/data/out/product_sales_facts.txt&amp;#39;
REPLACE INTO TABLE product_sale_facts FIELDS TERMINATED BY &amp;#39;,&amp;#39; (`id`,`date_id`,`order_id`,`product_id`,`address_id`,`unit_price`,`purchase_price`,`gross_profit`,`quantity`,`channel_id`,`gift`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入行数：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;wc -l &amp;lt; /Users/hooopo/data/out/product_sales_facts.txt
 1271413
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概130w数据用时16秒，平均每秒插入8w条记录左右。如果想用Gem，可以试试 adapter&lt;em&gt;extensions 和 load&lt;/em&gt;data_infile：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;https://github.com/activewarehouse/adapter_extensions&lt;/li&gt;
&lt;li&gt;https://github.com/EmmanuelOga/load&lt;em&gt;data&lt;/em&gt;infile&lt;/li&gt;
&lt;li&gt;https://github.com/jsuchal/activerecord-fast-import&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL Doc里关于LOAD INFILE的详细介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http://dev.mysql.com/doc/refman/5.5/en/load-data.html&lt;/li&gt;
&lt;li&gt;http://dev.mysql.com/doc/refman/5.5/en/insert-speed.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/2014/11/08/fastest-way-to-load-data-in-mysql.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/2014/11/08/fastest-way-to-load-data-in-mysql.html</guid>
        
        
      </item>
    
      <item>
        <title>Fastest Way To Change Schema In MySQL</title>
        <description>&lt;p&gt;在默认情况，Rails的migration会为每个语句单独生成一条SQL来修改表结构。这对新建的表来说是无所谓的，一个create table 或 alter table都是瞬间完成。但是，对于已经存在大量数据的表来说，这样效率极低。刚开始没有注意这样的问题，order表的写法：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;rename_column :orders, &amp;quot;shipping_first_name&amp;quot;, &amp;quot;origin_shipping_first_name&amp;quot;
rename_column :orders, &amp;quot;shipping_last_name&amp;quot;, &amp;quot;origin_shipping_last_name&amp;quot;
remove_column :orders, &amp;quot;coupon_value&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果就是，每一个rename&lt;em&gt;column和remove&lt;/em&gt;column执行时间大约4分钟，一共20多个这样的语句，migrate总计执行了近两个小时。因为alter table时mysql需要把整个order表copy to tmp table，而order表是非常庞大的。&lt;/p&gt;

&lt;p&gt;解决办法是把上面的所有修改order的migration合并成一个，并且设置bulk 选项。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class RenameOldOrderAddressRelatedColumn &amp;lt; ActiveRecord::Migration
  def up
    change_table(:orders, :bulk =&amp;gt; true) do |t|
      t.remove :coupon_code
      t.remove :coupon_value
      t.remove :order_promotion_id
      t.rename :order_status_code_id, :state
      t.remove :in_process
      [:first_name,
       :last_name,
       :phone,
       :street_address,
       :city,
       :zip,
       :company,
       :street_address_2,
       :country,
       :state].each do |column|
        t.rename &amp;quot;shipping_#{column}&amp;quot;, &amp;quot;origin_shipping_#{column}&amp;quot;
        t.rename &amp;quot;billing_#{column}&amp;quot;, &amp;quot;origin_billing_#{column}&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，上面的migration只生成一条SQL语句：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;ALTER TABLE `orders` DROP `coupon_code`, DROP `coupon_value`, DROP `order_promotion_id`, CHANGE `shipping_first_name` `origin_shipping_first_name` varchar(50) DEFAULT NULL, CHANGE `billing_first_name` `origin_billing_first_name` varchar(50) DEFAULT NULL, CHANGE `shipping_last_name` `origin_shipping_last_name` varchar(50) DEFAULT NULL, CHANGE `billing_last_name` `origin_billing_last_name` varchar(50) DEFAULT NULL, CHANGE `shipping_phone` `origin_shipping_phone` varchar(20) DEFAULT NULL, CHANGE `billing_phone` `origin_billing_phone` varchar(20) DEFAULT NULL, CHANGE `shipping_street_address` `origin_shipping_street_address` varchar(255) DEFAULT NULL, CHANGE `billing_street_address` `origin_billing_street_address` varchar(255) DEFAULT NULL, CHANGE `shipping_city` `origin_shipping_city` varchar(255) DEFAULT NULL, CHANGE `billing_city` `origin_billing_city` varchar(255) DEFAULT NULL, CHANGE `shipping_zip` `origin_shipping_zip` varchar(20) DEFAULT NULL, CHANGE `billing_zip` `origin_billing_zip` varchar(20) DEFAULT NULL, CHANGE `shipping_company` `origin_shipping_company` varchar(255) DEFAULT NULL, CHANGE `billing_company` `origin_billing_company` varchar(255) DEFAULT NULL, CHANGE `shipping_street_address_2` `origin_shipping_street_address_2` varchar(255) DEFAULT NULL, CHANGE `billing_street_address_2` `origin_billing_street_address_2` varchar(255) DEFAULT NULL, CHANGE `shipping_country` `origin_shipping_country` varchar(255) DEFAULT NULL, CHANGE `billing_country` `origin_billing_country` varchar(255) DEFAULT NULL, CHANGE `shipping_state` `origin_shipping_state` varchar(255) DEFAULT NULL, CHANGE `billing_state` `origin_billing_state` varchar(255) DEFAULT NULL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面修改，整个migration执行时间降到了十分钟以内。&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/2014/11/08/fastest-way-to-change-schema-in-mysql.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/2014/11/08/fastest-way-to-change-schema-in-mysql.html</guid>
        
        
      </item>
    
      <item>
        <title>Advanced Bitmask Attributes for SQL</title>
        <description>&lt;h1&gt;Advanced Bitmask Attributes for SQL&lt;/h1&gt;

&lt;h2&gt;Use Case&lt;/h2&gt;

&lt;p&gt;假设你正在为一个电商网站开发这样一种功能，商品可以在后台分配到不同的频道里显示（当然，一个商品可以在多个频道显示）。
另外有一个前提是，频道数目不多（10个以内）。&lt;/p&gt;

&lt;h2&gt;Bitmask&lt;/h2&gt;

&lt;p&gt;最常规的做法是加两张表，一个频道表，另一个是频道和商品中间表，标记频道和商品对应关系。这种做法的缺点是查询的时候需要JOIN两张表。再加上对商品本身的属性进行过滤和排序，查询会非常慢。&lt;/p&gt;

&lt;p&gt;一个简化的办法就是使用Bitmask Attributes。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;class Product &amp;lt; AR
  Channel1 = 1 &amp;lt;&amp;lt; 0 # 1
  Channel2 = 1 &amp;lt;&amp;lt; 1 # 2
  Channel3 = 1 &amp;lt;&amp;lt; 2 # 4
  Channel4 = 1 &amp;lt;&amp;lt; 3 # 8
end

# == Schema Information
#
# Table name: products
#
#  id                        :integer          not null, primary key
#  channels                  :integer
#  retail_price              :decimal(8, 2)    default(0.0), not null
#  purchase_price            :decimal(8, 2)    default(0.0), not null
#  image                     :string(255)
#  weight                    :integer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;存储&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果一个商品能在Channel1和Channel2里显示： channels =&amp;gt; 1 + 2 = 3&lt;/li&gt;
&lt;li&gt;如果一个商品能在Channel2和Channel2和Channel3显示： channels =&amp;gt; 1 + 2 + 4 = 7&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;查询能在Channel1显示的商品: &lt;code&gt;Product.where(&amp;quot;channels &amp;amp; 1 = 1&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询能在Channel1和Channel2显示的商品：&lt;code&gt;Product.where(&amp;quot;channels &amp;amp; 3 = 3&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询不能在Channel3显示的商品：&lt;code&gt;Product.where(&amp;quot;channels &amp;amp; 4 = 0&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;优缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;优点：更少的字段、更少的表解决了问题&lt;/li&gt;
&lt;li&gt;缺点：所有需要过滤channels字段的查询都为全表扫描，无法利用索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Advanced Bitmask Attributes&lt;/h3&gt;

&lt;p&gt;继续使用Bitmask的思路，但是把查询转化成IN查询，有效利用索引。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查询能在Channel1显示的商品:
&lt;code&gt;ruby
Product.where(:channels =&amp;gt; (1...(1 &amp;lt;&amp;lt; 4)).select{|x| x &amp;amp; 1 == 1})
# 产生SQL
SELECT `products`.* FROM `products`  WHERE `products`.`channels` IN (1, 3, 5, 7, 9, 11, 13, 15)&amp;quot;
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询能在Channel1和Channel2显示的商品：
&lt;code&gt;ruby
Product.where(:channels =&amp;gt; (1...(1 &amp;lt;&amp;lt; 4)).select{|x| x &amp;amp; 3 == 3})
# 产生SQL
SELECT `products`.* FROM `products`  WHERE `products`.`channels` IN (3, 7, 11, 15)
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查询不能在Channel3显示的商品：
&lt;code&gt;ruby
Product.where(:channels =&amp;gt; (1...(1 &amp;lt;&amp;lt; 4)).select{|x| x &amp;amp; 4 == 0})
# 产生SQL
SELECT `products`.* FROM `products`  WHERE `products`.`channels` IN (1, 2, 3, 8, 9, 10, 11)
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;结论&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;中间表方案：需要额外的JOIN Table&lt;/li&gt;
&lt;li&gt;Bitmask Attributes：需要Full Table Scan&lt;/li&gt;
&lt;li&gt;Advanced Bitmask Attributes：No JOIN,No Full Table Scan.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 08 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/2014/11/08/advanced-bitmask-attributes-for-sql.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/2014/11/08/advanced-bitmask-attributes-for-sql.html</guid>
        
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code&gt;jekyll serve --watch&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;def print_hi(name)
  puts &amp;quot;Hi, #{name}&amp;quot;
end
print_hi(&amp;#39;Tom&amp;#39;)
#=&amp;gt; prints &amp;#39;Hi, Tom&amp;#39; to STDOUT.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://github.com/jekyll/jekyll-help&quot;&gt;Jekyll’s dedicated Help repository&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Nov 2014 02:08:09 +0800</pubDate>
        <link>http://shopperplus.github.io/blog/jekyll/update/2014/11/06/welcome-to-jekyll.html</link>
        <guid isPermaLink="true">http://shopperplus.github.io/blog/jekyll/update/2014/11/06/welcome-to-jekyll.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
